
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Shelter</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Donald Wu">
    

    
    <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Shelter">
<meta property="og:url" content="http://wuyihao14.github.io/page/4/index.html">
<meta property="og:site_name" content="Shelter">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Shelter">
<meta name="twitter:description">

    
    <link rel="alternative" href="/atom.xml" title="Shelter" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Shelter" title="Shelter"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Shelter">Shelter</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜單">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:wuyihao14.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/02/MonteCarlo优化实操/" title="MonteCarlo优化实操" itemprop="url">MonteCarlo优化实操</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Donald Wu" target="_blank" itemprop="author">Donald Wu</a>
		
  <p class="article-time">
    <time datetime="2015-11-02T10:42:59.331Z" itemprop="datePublished"> 發表於 2015-11-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>学习Intel练习课<br>Hands-on Lab: Optimize Your Code for the Latest Intel®<br>XeonTM Processors and Intel® Xeon PhiTM Coprocessor<br>using Intel® Parallel Studio XE for Linux*</p>
<h1 id="Stage_1">Stage 1</h1><p>暂时不用考虑MonteCarlo的原理。Stage 1先后使用了gcc和icpc，并没有显著的进步。给我们的练习是使用mkl的并行随机数生成器。其目的就是对比mkl和串行随机数生成器的效率。mkl历史悠久，具有很高的可靠性，我们优化的时候，首先应该考虑这种集成度高的方式。</p>
<p>Intel的Developer Zone上有在线的API文档，查阅很方便。</p>
<pre><code>typedef <span class="symbol">std:</span><span class="symbol">:tr1</span><span class="symbol">:</span><span class="symbol">:mt19937</span>                     <span class="constant">ENG</span>;    <span class="regexp">//</span> <span class="constant">Mersenne</span> <span class="constant">Twister</span>
typedef <span class="symbol">std:</span><span class="symbol">:tr1</span><span class="symbol">:</span><span class="symbol">:normal_distribution&lt;float&gt;</span> <span class="constant">DIST</span>;   <span class="regexp">//</span> <span class="constant">Normal</span> <span class="constant">Distribution</span>
typedef <span class="symbol">std:</span><span class="symbol">:tr1</span><span class="symbol">:</span><span class="symbol">:variate_generator&lt;ENG</span>,<span class="constant">DIST</span>&gt; <span class="constant">GEN</span>;    <span class="regexp">//</span> <span class="constant">Variate</span> generator
</code></pre><p>这些声明替换为如下：</p>
<pre><code><span class="attribute">float</span> myrand<span class="attr_selector">[RAND_N]</span>;
VSLStreamStatePtr stream;
<span class="function">vslNewStream</span>(&amp;stream, VSL_BRNG_MT19937, 777);
</code></pre><p>一开始的时候，我一次性生成了两重循环需要的所有随机数，没有发现OPT_N<em>RAND_N已经达十亿。不得已，只能在内层循环外生成OPT_N</em>RAND_N个随机数。</p>
<pre><code><span class="title">vsRngGaussian(VSL_RNG_METHOD_GAUSSIAN_ICDF,stream,RAND_N,myrand,0</span><span class="number">.0</span>,<span class="number">1.0</span>);
</code></pre><p>vRngGaussian有double版和float版，分别是vdRngGaussian和vsRngGaussian。</p>
<p>在外层循环外删掉stream。</p>
<pre><code><span class="function">vslDeleteStream</span>(&amp;stream);
</code></pre><p>链接的时候又遇到了障碍，需要的所有库都得链接。</p>
<pre><code>icc .<span class="regexp">/MonteCarloStep1.cpp ./</span>Driver.cpp -I<span class="regexp">/opt/i</span>ntel<span class="regexp">/composerxe/m</span>kl<span class="regexp">/include -L/</span>opt<span class="regexp">/intel/</span>composexe<span class="regexp">/mkl/</span>lib<span class="regexp">/intel64 -lmkl_intel_lp64 -lmkl_intel_thread -lmkl_core -lmkl_lapack95_lp64 -liomp5 -lpthread -O2 -o MonteCarlo</span>
</code></pre><p>结果如下：总算是完成了。</p>
<pre><code>Monte Carlo European <span class="keyword">Option</span> Pricinig <span class="keyword">in</span> <span class="built_in">Single</span> Precision
Pricing <span class="number">32768</span> <span class="keyword">Option</span> <span class="keyword">with</span> path length <span class="keyword">of</span> <span class="number">262144.</span>
Completed <span class="keyword">in</span> <span class="number">151.4866</span> seconds.
Computation rate - <span class="number">216.3096</span>.
</code></pre><p>对照答案，发现答案有一点问题，每一次蒙特卡洛的模拟的随机变量是相同的，这样我觉得貌似失去了重复实验的意义，不排除是我对蒙特卡洛的理解出了问题。但是在效率上，仅一次生成RAND_N个随机数，的确提高了速度。</p>
<h1 id="Stage_2">Stage 2</h1><p>这几种优化手段都是第一次见到。float常量后面加上f，区分float和double对应的数学函数，减少冗余计算，避免类型转换，利用intel的计算比较快的数学函数。我对照答案修改之后的运行结果：（不过不是在同一个集群，没有参照性）</p>
<p>Monte Carlo European Option Pricinig in Single Precision<br>Pricing 32768 Option with path length of 262144.<br>Completed in  33.9102 seconds.<br>Computation rate - 966.3183.</p>
<p>而不用我的这些优化（不明白为什么答案没有优化这些地方，也许是我搞错了），时间是77s</p>
<p>对照答案，不明白为什么有的float常量后面写了f，有的没有。把强制转换预处理计算了，或者去掉了。为什么有个地方没有使用exp2f。为什么要把除法拿出来？为什么有的冗余计算给提前了，有的（如(<font color="blue">RISKFREE - 0.5 <em> VOLATILITY </em> VOLATILITY)*M_LOG2E</font>）则没有？static_cast和普通类型转换的区别？</p>
<h1 id="Stage_3">Stage 3</h1><p>由于向量化是书上着重讲的部分，于是我先自己实验，再看步骤。</p>
<p>-vec-report=3显示内层循环被向量化了，外层没有<br>使用#pragma ivdep没有用<br>观察发现，貌似并没有数据依赖，于是#pragma simd，时间从原来的77s变成了57s<br>进行到这里，感觉对我来说，已经完成了向量化工作。。。于是看资料</p>
<p>原来此文把内核级优化的内容也放到了该vectorization小节里。继续自己做实验。</p>
<p><strong>切片</strong>，由于L2 cache是256KB，而RAND_N是2^18，l_Random是float数组，float是4字节，切成4块刚好每一块装满L2 cache，对于每个opt，处理长度为RAND_N/4的pos区间，这样提高了命中率，还不至于使内层循环并行度过低。时间从57s减少到了49s。<br><strong>对齐</strong>，我有点犯晕，是否只有动态生成的内存才在这个问题上可控？<br><strong>函数</strong>，这些函数应该都有对应的SIMD版本，会自动使用吧</p>
<p>又没有思路了。</p>
<p><strong>reduction</strong>，如果不使用reduction，当数据量大了之后，可能出现竞争的问题，导致结果出错，reduction会给每一个线程一个副本，使用了reduction之后，外层循环不能向量化了，但是时间减为了14s。这是怎么回事？遂去掉了#pragma simd</p>
<hr>
<p>照答案重做一遍<br>原始77s<br><strong>向量对齐</strong> 声明数组时<strong>attribute</strong>((aligne(64)) float l_Random[RAND_N]，第一维的首地址对齐。<font color="red">我想知道多维数组有什么不同。</font><br>然后#pragma vector aligned，声明向量已对齐<br>#pragma simd reduction(+:val) reduction(+:val2)用编译器自己向量化即可，不用openmp<font color="red">我还不明白openmp到底是干嘛的</font><br>#pragma unroll(4)，展开了四次，因为里面加了一句话（因为max里计算了两次复杂表达式，手动展开了）总共四句<br>时间13s</p>
<h1 id="Stage_4">Stage 4</h1><p>计算是独立的，外层确实应该是可以向量化的<br>用openmp并行化外层循环<br>#pragma omp parallel for<br>平均时间1s</p>
<font color="red">我不明白为什么可以用openmp而不能用simd。我确实需要复习openmp了，至少搞懂它到底是啥</font>

<h1 id="Stage_5">Stage 5</h1><p>mic的native模式，平均时间0.5s</p>
<font color="red">明天继续补充，对照答案检查</font>

<p>我想自己做一点激进的实验，可是又没办法保证结果的正确，希望能找到什么资料讨论这个问题<br>当各个部件都熟悉了，问题会变成如何构建多级异构，如何使OpenMP、MPI等协调工作。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/HPC/">HPC</a>
</div>


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/02/AlicesPrintSerive_二分/" title="Alice&#39;s Print Service 二分" itemprop="url">Alice&#39;s Print Service 二分</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Donald Wu" target="_blank" itemprop="author">Donald Wu</a>
		
  <p class="article-time">
    <time datetime="2015-11-02T10:42:59.327Z" itemprop="datePublished"> 發表於 2015-11-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Alice’s Print Service<br>Time Limit: 1000MS        Memory Limit: 32768KB        64bit IO Format: %I64d &amp; %I64u<br>Submit</p>
<p>Status</p>
<p>Description<br>Alice is providing print service, while the pricing doesn’t seem to be reasonable, so people using her print service found some tricks to save money.<br>For example, the price when printing less than 100 pages is 20 cents per page, but when printing not less than 100 pages, you just need to pay only 10 cents per page. It’s easy to figure out that if you want to print 99 pages, the best choice is to print an extra blank page so that the money you need to pay is 100 × 10 cents instead of 99 × 20 cents.<br>Now given the description of pricing strategy and some queries, your task is to figure out the best ways to complete those queries in order to save money.</p>
<p>Input<br>The first line contains an integer T (≈ 10) which is the number of test cases. Then T cases follow.<br>Each case contains 3 lines. The first line contains two integers n, m (0 &lt; n, m ≤ 10 5 ). The second line contains 2n integers s 1, p 1 , s 2, p 2 , …, s n, p n (0=s 1 &lt; s 2 &lt; … &lt; s n ≤ 10 9 , 10 9 ≥ p 1 ≥ p 2 ≥ … ≥ p n ≥ 0).. The price when printing no less than s i but less than s i+1 pages is p i cents per page (for i=1..n-1). The price when printing no less than s n pages is p n cents per page. The third line containing m integers q 1 .. q m (0 ≤ q i ≤ 10 9 ) are the queries.</p>
<p>Output<br>For each query q i, you should output the minimum amount of money (in cents) to pay if you want to print q i pages, one output in one line.</p>
<p>Sample Input<br> 1<br>2 3<br>0 20 100 10<br>0 99 100 </p>
<p>Sample Output<br> 0<br>1000<br>1000 </p>
<p>Source<br>2013 Asia Changsha Regional Contest</p>
<p>打印必须选择页数大于q的方案，如果选择页数刚好大于q的方案（即s[i]&lt;=q&lt;s[i+1]）方案，可以只打印q页，否则必须打印s[i]页（价格为s[i]*p[i]）。后者是区间最小值问题，用二分解决。再与前者比较选较小即可。</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;

<span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;
<span class="keyword">int</span> n,m;
ll a[N],s[N],t[N];

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
    <span class="keyword">int</span> T;
    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);
    <span class="keyword">while</span> (T--){
        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);
        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){
            <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,s+i,t+i);
            a[i] = s[i]*t[i];
        }
        a[n] = <span class="number">0x3f3f3f3f3f3f3f3f</span>ll;
        <span class="keyword">for</span> (<span class="keyword">int</span> i=n-<span class="number">2</span>;i&gt;-<span class="number">1</span>;i--){
            a[i] = a[i]&lt;a[i+<span class="number">1</span>]?a[i]:a[i+<span class="number">1</span>];
        }
        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){
            ll q;
            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;q);
            <span class="keyword">int</span> ind = upper_bound(s,s+n,q)-s;
            ll ans = t[ind-<span class="number">1</span>]*q;
            <span class="keyword">if</span> (ans &gt; a[ind]) ans = a[ind];

            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);
        }
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/ACM/">ACM</a>
</div>


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/02/底层并行实验记录/" title="底层并行实验" itemprop="url">底层并行实验</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Donald Wu" target="_blank" itemprop="author">Donald Wu</a>
		
  <p class="article-time">
    <time datetime="2015-11-02T10:42:59.327Z" itemprop="datePublished"> 發表於 2015-11-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="多进程实验">多进程实验</h2><pre><code><span class="comment">#include &lt;unistd.h&gt; //fork&amp;wait&amp;getpid..</span>
<span class="comment">#include &lt;stdlib.h&gt;</span>
<span class="comment">#include &lt;signal.h&gt; //kill</span>
<span class="comment">#include &lt;sys/types.h&gt;</span>
<span class="comment">#include &lt;stdio.h&gt;</span>

<span class="comment">#define NUM_THREADS 3</span>

void tryfork(){
    <span class="keyword">int</span> i;
    pid_t <span class="sub"><span class="keyword">sub</span>[NUM_THREADS];</span>
    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;NUM_THREADS;i++){
        <span class="sub"><span class="keyword">sub</span>[i] = fork();</span>
        //<span class="keyword">printf</span>(<span class="string">"DEBUG <span class="variable">%d</span> , <span class="variable">%d</span>\n"</span>,i,<span class="sub"><span class="keyword">sub</span>[i]);</span>
        <span class="keyword">if</span> (<span class="sub"><span class="keyword">sub</span>[i] == -1){</span>
            fprintf(stderr, <span class="string">"ERROR while fork"</span>);
        }<span class="keyword">else</span> <span class="keyword">if</span> (<span class="sub"><span class="keyword">sub</span>[i] == 0){</span> //子进程
            <span class="keyword">sleep</span>(<span class="number">2</span>); <span class="regexp">//</span>测试<span class="keyword">wait</span>
            <span class="keyword">printf</span>(<span class="string">"I am the child #<span class="variable">%d</span> pid=<span class="variable">%d</span>\n"</span>, i, getpid()); <span class="regexp">//fork</span>是多进程
        }<span class="keyword">else</span>{
            <span class="keyword">waitpid</span>(<span class="sub"><span class="keyword">sub</span>[i],NULL,0);</span> //只能是等待子进程，第三个参数很重要，回去再研究
            <span class="keyword">printf</span>(<span class="string">"I am the father #<span class="variable">%d</span> pid=<span class="variable">%d</span> my son is <span class="variable">%d</span>\n"</span>,i, getpid(),<span class="sub"><span class="keyword">sub</span>[i]);</span>
            <span class="keyword">return</span>; <span class="regexp">//</span>避免二叉树
        }
    }
}

void tryexec(){
    execve(<span class="string">"./tryexec"</span>,NULL,NULL);
}
void trykill(){
    <span class="keyword">int</span> pid = <span class="keyword">fork</span>();
    <span class="keyword">if</span> (pid == -<span class="number">1</span>){
        fprintf(stderr, <span class="string">"ERROR while fork"</span>);
    }<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>){
        <span class="keyword">sleep</span>(<span class="number">1</span>);
        <span class="keyword">printf</span>(<span class="string">"I am the child\n"</span>);
    }<span class="keyword">else</span>{
        <span class="keyword">kill</span>(pid,<span class="number">9</span>);<span class="regexp">//</span>回去再研究各种信号
    }
}

void sigcat(){
    <span class="keyword">printf</span>(<span class="string">"SIGNAL Triggered\n"</span>);
}

typedef void (*sighandler_t)(<span class="keyword">int</span>);

void trypause(){
    signal(SIGINT,(sighandler_t)sigcat);<span class="regexp">//</span>注册信号！！
    <span class="keyword">int</span> pid = <span class="keyword">fork</span>();
    <span class="keyword">if</span> (pid == -<span class="number">1</span>){
        fprintf(stderr, <span class="string">"ERROR while fork"</span>);
        <span class="keyword">exit</span>(EXIT_FAILURE);
    }<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>){
        pause();
        <span class="keyword">printf</span>(<span class="string">"I am the child\n"</span>);
        <span class="keyword">exit</span>(EXIT_FAILURE);
    }<span class="keyword">else</span>{
        <span class="keyword">waitpid</span>(pid,NULL,<span class="number">0</span>);
        <span class="keyword">if</span> (<span class="keyword">kill</span>(pid,SIGINT) &gt;= <span class="number">0</span>){
            <span class="keyword">printf</span>(<span class="string">"Child woke up\n"</span>);
    }
}

<span class="keyword">int</span> main(){
    <span class="regexp">//tryfork</span>();
    <span class="regexp">//tryexec</span>();
    <span class="regexp">//trykill</span>();
    trypause();
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><h3 id="1-_fork实验：">1. fork实验：</h3><p>一个父进程fork，只能编程两个进程，若要实现一个进程派生出多个进程，仅仅循环fork，或者连续fork，这样会变成一棵二叉树。可以用return的方法，主进程执行完自己的任务后，不再fork。<br>fork是多进程，而不是多线程，父进程可以维护子进程的pid，多进程可以用父子关系，也可以表示成兄弟关系，看具体实现方式。<br>wait和waitpid，要注意options选项，WNOHANG指定wait no hang，不阻塞，而子进程的状态存在第二个参数status中，可以由父进程轮训，小心这是默认选项，因此如果不处理，则会“看起来”不像wait。</p>
<h3 id="2-_exec实验：">2. exec实验：</h3><p>exec家族一共有六个函数，分别是：<br>(1)int execl(const char <em>path, const char </em>arg, ……);<br>(2)int execle(const char <em>path, const char </em>arg, …… , char <em> const envp[]);<br>(3)int execv(const char </em>path, char <em>const argv[]);<br>(4)int execve(const char </em>filename, char <em>const argv[], char </em>const envp[]);<br>(5)int execvp(const char <em>file, char </em> const argv[]);<br>(6)int execlp(const char <em>file, const char </em>arg, ……);<br>其中只有execve是真正意义上的系统调用，其它都是在此基础上经过包装的库函数。<br>exec函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。这里的可执行文件既可以是二进制文件，也可以是任何Linux下可执行的脚本文件。若失败则返回-1，并继续执行原程序。<br>第一个区别是：<br>前四个取路径名做为参数，后两个取文件名做为参数，如果文件名中不包含 “/” 则从PATH环境变量中搜寻可执行文件， 如果找到了一个可执行文件，但是该文件不是连接编辑程序产生的可执行代码文件，则当做shell脚本处理。<br>第二个区别：<br>前两个和最后一个函数中都包括“ l ”这个字母 ，而另三个都包括“ v ”， “ l “代表 list即表 ，而” v “代表 vector即矢量，也是是前三个函数的参数都是以list的形式给出的，但最后要加一个空指针，如果用常数0来表示空指针，则必须将它强行转换成字符指针，否则有可能出错。，而后三个都是以矢量的形式给出，即数组。<br>最后一个区别：<br>与向新程序传递环境变量有关，如第二个和第四个以e结尾的函数，可以向函数传递一个指向环境字符串指针数组的指针。即自个定义各个环境变量，而其它四个则使用进程中的环境变量。</p>
<h3 id="3-_kill实验">3. kill实验</h3><p>kill -l 列出信号<br>1) SIGHUP<br>本信号在用户终端连接(正常或非正常)结束时发出, 通常是在终端的控制进程结束时, 通知同一session内的各个作业, 这时它们与控制终端不再关联。</p>
<p>登录Linux时，系统会分配给登录用户一个终端(Session)。在这个终端运行的所有程序，包括前台进程组和后台进程组，一般都属于这个 Session。当用户退出Linux登录时，前台进程组和后台有对终端输出的进程将会收到SIGHUP信号。这个信号的默认操作为终止进程，因此前台进 程组和后台有终端输出的进程就会中止。不过可以捕获这个信号，比如wget能捕获SIGHUP信号，并忽略它，这样就算退出了Linux登录，wget也 能继续下载。</p>
<p>此外，对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。<br>2) SIGINT<br>程序终止(interrupt)信号, 在用户键入INTR字符(通常是Ctrl-C)时发出，用于通知前台进程组终止进程。<br>3) SIGQUIT<br>和SIGINT类似, 但由QUIT字符(通常是Ctrl-)来控制. 进程在因收到SIGQUIT退出时会产生core文件, 在这个意义上类似于一个程序错误信号。<br>4) SIGILL<br>执行了非法指令. 通常是因为可执行文件本身出现错误, 或者试图执行数据段. 堆栈溢出时也有可能产生这个信号。<br>5) SIGTRAP<br>由断点指令或其它trap指令产生. 由debugger使用。<br>6) SIGABRT<br>调用abort函数生成的信号。<br>7) SIGBUS<br>非法地址, 包括内存地址对齐(alignment)出错。比如访问一个四个字长的整数, 但其地址不是4的倍数。它与SIGSEGV的区别在于后者是由于对合法存储地址的非法访问触发的(如访问不属于自己存储空间或只读存储空间)。<br>8) SIGFPE<br>在发生致命的算术运算错误时发出. 不仅包括浮点运算错误, 还包括溢出及除数为0等其它所有的算术的错误。<br>9) SIGKILL<br>用来立即结束程序的运行. 本信号不能被阻塞、处理和忽略。如果管理员发现某个进程终止不了，可尝试发送这个信号。<br>10) SIGUSR1<br>留给用户使用<br>11) SIGSEGV<br>试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据.<br>12) SIGUSR2<br>留给用户使用<br>13) SIGPIPE<br>管道破裂。这个信号通常在进程间通信产生，比如采用FIFO(管道)通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到SIGPIPE信号。此外用Socket通信的两个进程，写进程在写Socket的时候，读进程已经终止。<br>14) SIGALRM<br>时钟定时信号, 计算的是实际的时间或时钟时间. alarm函数使用该信号.<br>15) SIGTERM<br>程序结束(terminate)信号, 与SIGKILL不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出，shell命令kill缺省产生这个信号。如果进程终止不了，我们才会尝试SIGKILL。<br>17) SIGCHLD<br>子进程结束时, 父进程会收到这个信号。</p>
<p>如果父进程没有处理这个信号，也没有等待(wait)子进程，子进程虽然终止，但是还会在内核进程表中占有表项，这时的子进程称为僵尸进程。这种情 况我们应该避免(父进程或者忽略SIGCHILD信号，或者捕捉它，或者wait它派生的子进程，或者父进程先终止，这时子进程的终止自动由init进程来接管)。<br>18) SIGCONT<br>让一个停止(stopped)的进程继续执行. 本信号不能被阻塞. 可以用一个handler来让程序在由stopped状态变为继续执行时完成特定的工作. 例如, 重新显示提示符…<br>19) SIGSTOP<br>停止(stopped)进程的执行. 注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行. 本信号不能被阻塞, 处理或忽略.<br>20) SIGTSTP<br>停止进程的运行, 但该信号可以被处理和忽略. 用户键入SUSP字符时(通常是Ctrl-Z)发出这个信号<br>21) SIGTTIN<br>当后台作业要从用户终端读数据时, 该作业中的所有进程会收到SIGTTIN信号. 缺省时这些进程会停止执行.<br>22) SIGTTOU<br>类似于SIGTTIN, 但在写终端(或修改终端模式)时收到.<br>23) SIGURG<br>有”紧急”数据或out-of-band数据到达socket时产生.<br>24) SIGXCPU<br>超过CPU时间资源限制. 这个限制可以由getrlimit/setrlimit来读取/改变。<br>25) SIGXFSZ<br>当进程企图扩大文件以至于超过文件大小资源限制。<br>26) SIGVTALRM<br>虚拟时钟信号. 类似于SIGALRM, 但是计算的是该进程占用的CPU时间.<br>27) SIGPROF<br>类似于SIGALRM/SIGVTALRM, 但包括该进程用的CPU时间以及系统调用的时间.<br>28) SIGWINCH<br>窗口大小改变时发出.<br>29) SIGIO<br>文件描述符准备就绪, 可以开始进行输入/输出操作.<br>30) SIGPWR<br>Power failure<br>31) SIGSYS<br>非法的系统调用。</p>
<p>并不知道大部分signal有什么用</p>
<h3 id="4-_pause实验">4. pause实验</h3><p>pause()将程序挂起，直到有系统signal将其唤醒<br>typedef void (*sighandler_t)(int);类型的函数指针<br>signal(xxx,(sighandler_t)sigcat);注册信号<br>kill失败返回-1，成功返回0</p>
<hr>
<p>练习程序，实现主进程派生出两个进程，分别exec两个程序，其中ps优先执行（将它作为ls进程的父进程）</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;signal.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;sys/types.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;unistd.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span>

<span class="preprocessor">#<span class="keyword">define</span> NUM_THREADS 2</span>

pid_t pid[NUM_THREADS];
<span class="keyword">char</span> * argv1[] = {<span class="string">"/bin/ls"</span>,<span class="string">"-a"</span>,NULL};
<span class="keyword">char</span> * argv2[] = {<span class="string">"/bin/ps"</span>,<span class="string">"aux"</span>,NULL};

<span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>{
    <span class="keyword">int</span> i;
    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;NUM_THREADS;i++){
        pid[i] = fork();
        <span class="keyword">if</span> (pid[i] == -<span class="number">1</span>){
            <span class="built_in">fprintf</span>(stderr,<span class="string">"ERROR while fork\n"</span>);
        }<span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(pid[i] == 0)</span></span>{
            <span class="keyword">if</span> (i == <span class="number">1</span>)
                execve(argv2[<span class="number">0</span>],&amp;argv2,NULL);
        }<span class="keyword">else</span>{
            <span class="keyword">if</span> (i==<span class="number">1</span>){
                waitpid(pid[<span class="number">1</span>],NULL,<span class="number">0</span>);
                execve(argv1[<span class="number">0</span>],&amp;argv1,NULL);
            }
        }
    }
}

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
    work();
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><hr>
<h2 id="进程同步实验">进程同步实验</h2><p>linux中IPC的三个对象：共享内存、信号量数组、消息队列，来解决协作并发进程间的同步和互斥问题。</p>
<p>共享内存：ipcs -m查看。<br>信号量数组：ipcs -s查看。<br>消息队列：ipcs -q 查看。</p>
<p>同上，删除用ipcrm</p>
<p>三个虚拟文件/proc/sysvipc/shm sem msg</p>
<p>头文件：sys/types.h、sys/ipc.h</p>
<p>主要函数：shmget shmat shmdt（不一定要显式调用，进程结束后会自动计数器减一） semget semop（PV操作） semctl msgget msgsnd msgrcv msgctl</p>
<p>本次实验利用共享内存和信号量两者实现了生产者消费者问题。</p>
<p>下面是ipc的封装程序，基于三个系统文件，完成了创建、赋初值、判重、PV操作等功能。</p>
<pre><code>#include <span class="string">"ipc.h"</span>

<span class="built_in">int</span> get_ipc_id(<span class="built_in">char</span>* proc_file,key_t <span class="variable">key</span>){
    FILE * pf;
    <span class="built_in">int</span> i,j;
    <span class="built_in">char</span> <span class="built_in">line</span>[BUFSZ],colum[BUFSZ];

    <span class="keyword">if</span> ((pf=fopen(proc_file,<span class="string">"r"</span>))==NULL){
        perror(<span class="string">"Proc file not open"</span>);
        <span class="built_in">exit</span>(EXIT_FAILURE);
    }
    fgets(<span class="built_in">line</span>,BUFSZ,pf);
    <span class="keyword">while</span> (!feof(pf)){
        i = j = <span class="number">0</span>;
        fgets(<span class="built_in">line</span> ,BUFSZ, pf);
        <span class="keyword">while</span> (<span class="built_in">line</span>[i]==<span class="string">' '</span>)i++;
        <span class="keyword">while</span> (<span class="built_in">line</span>[i]!=<span class="string">' '</span>)colum[j++]=<span class="built_in">line</span>[i++];
        colum[j] = <span class="string">'\0'</span>;
        <span class="keyword">if</span> (atoi(colum)!=<span class="variable">key</span>) <span class="keyword">continue</span>;
        j = <span class="number">0</span>;
        <span class="keyword">while</span> (<span class="built_in">line</span>[i]==<span class="string">' '</span>)i++;
        <span class="keyword">while</span> (<span class="built_in">line</span>[i]!=<span class="string">' '</span>)colum[j++]=<span class="built_in">line</span>[i++];
        colum[j] = <span class="string">'\0'</span>;
        i = atoi(colum);
        fclose(pf);
        <span class="keyword">return</span> i;
    }
    fclose(pf);
    <span class="keyword">return</span> -<span class="number">1</span>;
}

<span class="built_in">int</span> down(<span class="built_in">int</span> sem_id){
    struct sembuf buf;
    buf.sem_op = -<span class="number">1</span>;
    buf.sem_num = <span class="number">0</span>;
    buf.sem_flg = SEM_UNDO;
    <span class="keyword">if</span> ((semop(sem_id,&amp;buf,<span class="number">1</span>))&lt;<span class="number">0</span>){
        perror(<span class="string">"down error"</span>);
        <span class="built_in">exit</span>(EXIT_FAILURE);
    }
    <span class="keyword">return</span> EXIT_SUCCESS;
}

<span class="built_in">int</span> up(<span class="built_in">int</span> sem_id){
    struct sembuf buf;
    buf.sem_op = <span class="number">1</span>;
    buf.sem_num = <span class="number">0</span>;
    buf.sem_flg = SEM_UNDO;
    <span class="keyword">if</span> ((semop(sem_id,&amp;buf,<span class="number">1</span>))&lt;<span class="number">0</span>){
        perror(<span class="string">"up error"</span>);
        <span class="built_in">exit</span>(EXIT_FAILURE);
    }
    <span class="keyword">return</span> EXIT_SUCCESS;
}

<span class="built_in">int</span> set_sem(key_t sem_key,<span class="built_in">int</span> sem_val,<span class="built_in">int</span> sem_flg){
    <span class="built_in">int</span> sem_id;
    Sem_uns sem_arg;

    <span class="keyword">if</span> ((sem_id = get_ipc_id(<span class="string">"/proc/sysvipc/sem"</span>,sem_key))&lt;<span class="number">0</span>){
        <span class="keyword">if</span> ((sem_id = semget(sem_key,<span class="number">1</span>,sem_flg))&lt;<span class="number">0</span>){
            perror(<span class="string">"semaphore create error"</span>);
            <span class="built_in">exit</span>(EXIT_FAILURE);
        }
        sem_arg.val = sem_val;
        <span class="keyword">if</span> (semctl(sem_id,<span class="number">0</span>,SETVAL,sem_arg)&lt;<span class="number">0</span>){
            perror(<span class="string">"semaphore set error"</span>);
            <span class="built_in">exit</span>(EXIT_FAILURE);
        }
    }
    <span class="keyword">return</span> sem_id;
}

<span class="built_in">char</span> * set_shm(key_t shm_key,<span class="built_in">int</span> shm_num,<span class="built_in">int</span> shm_flg){
    <span class="built_in">int</span> i,shm_id;
    <span class="built_in">char</span> * shm_buf;

    <span class="keyword">if</span> ((shm_id = get_ipc_id(<span class="string">"/proc/sysvipc/shm"</span>,shm_key))&lt;<span class="number">0</span>){
        <span class="keyword">if</span> ((shm_id = shmget(shm_key,shm_num,shm_flg))&lt;<span class="number">0</span>){
            perror(<span class="string">"shareMemory set error"</span>);
            <span class="built_in">exit</span>(EXIT_FAILURE);
        }
        <span class="keyword">if</span> ((shm_buf=(<span class="built_in">char</span>*)shmat(shm_id,<span class="number">0</span>,<span class="number">0</span>)) &lt; (<span class="built_in">char</span>*)<span class="number">0</span>){
            perror(<span class="string">"get shareMemory error"</span>);
            <span class="built_in">exit</span>(EXIT_FAILURE);
        }
        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;shm_num;i++) shm_buf[i] = <span class="number">0</span>;
    }
    <span class="comment">//</span>
    <span class="keyword">if</span> ((shm_buf = (<span class="built_in">char</span>*)shmat(shm_id,<span class="number">0</span>,<span class="number">0</span>))&lt;(<span class="built_in">char</span>*)<span class="number">0</span>){
        perror(<span class="string">"get shareMemory error"</span>);
        <span class="built_in">exit</span>(EXIT_FAILURE);
    }
    <span class="keyword">return</span> shm_buf;
}

<span class="built_in">int</span> set_msq(key_t msq_key,<span class="built_in">int</span> msq_flg){
    <span class="built_in">int</span> msq_id;

    <span class="keyword">if</span> ((msq_id = get_ipc_id(<span class="string">"/proc/sysvipc/msg"</span>,msq_key))&lt;<span class="number">0</span>){
        <span class="keyword">if</span> ((msq_id==msgget(msq_key,msq_flg))&lt;<span class="number">0</span>){
            perror(<span class="string">"messageQueue set error"</span>);
            <span class="built_in">exit</span>(EXIT_FAILURE);
        }
    }
    <span class="keyword">return</span> msq_id;
}
</code></pre><p>头文件：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;sys/types.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;sys/ipc.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;sys/shm.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;sys/sem.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;sys/msg.h&gt;</span>
<span class="preprocessor">#<span class="keyword">define</span> BUFSZ 256</span>

<span class="function"><span class="keyword">int</span> <span class="title">get_ipc_id</span><span class="params">(<span class="keyword">char</span> *proc_file,key_t key)</span></span>;

<span class="keyword">char</span> *set_shm(key_t shm_key,<span class="keyword">int</span> shm_num,<span class="keyword">int</span> shm_flag);

<span class="function"><span class="keyword">int</span> <span class="title">set_msg</span><span class="params">(key_t msq_key,<span class="keyword">int</span> msq_flag)</span></span>;

<span class="function"><span class="keyword">int</span> <span class="title">set_sem</span><span class="params">(key_t sem_key,<span class="keyword">int</span> sem_val,<span class="keyword">int</span> sem_flag)</span></span>;

<span class="function"><span class="keyword">int</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span>;

<span class="function"><span class="keyword">int</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span>;

<span class="keyword">typedef</span> <span class="keyword">union</span> semuns{
    <span class="keyword">int</span> val;
}Sem_uns;

<span class="keyword">typedef</span> <span class="keyword">struct</span> msgbuf{
    <span class="keyword">long</span> mtype;
    <span class="keyword">char</span> mtext[<span class="number">1</span>];
}Msg_buf;

key_t buff_key;

<span class="keyword">int</span> buff_num;
<span class="keyword">char</span> * buff_ptr;

key_t pput_key;
<span class="keyword">int</span> pput_num;
<span class="keyword">int</span> * pput_ptr;

key_t cget_key;
<span class="keyword">int</span> cget_num;
<span class="keyword">int</span> *cget_ptr;

key_t prod_key;
key_t pmtx_key;
<span class="keyword">int</span> prod_sem;

key_t cons_key;
key_t cmtx_key;
<span class="keyword">int</span> cons_sem;
<span class="keyword">int</span> cmtx_sem;

key_t prod_key;
key_t pmtx_key;
<span class="keyword">int</span> prod_sem;
<span class="keyword">int</span> pmtx_sem;

<span class="keyword">int</span> sem_val;
<span class="keyword">int</span> sem_flg;
<span class="keyword">int</span> shm_flg;
</code></pre><p>生产者：</p>
<pre><code><span class="comment">#include "ipc.h"</span>

int main(int argc,char * argv[]){
    int rate;
    <span class="keyword">if</span> (argv[<span class="number">1</span>] != NULL) <span class="variable">rate =</span> atoi(argv[<span class="number">1</span>]);
    <span class="keyword">else</span> <span class="variable">rate =</span> <span class="number">3</span>;

    <span class="variable">buff_key =</span> <span class="number">101</span>;
    <span class="variable">buff_num =</span> <span class="number">8</span>;
    <span class="variable">pput_key =</span> <span class="number">102</span>;
    <span class="variable">pput_num =</span> <span class="number">1</span>;
    <span class="variable">shm_flg =</span> IPC_CREAT|<span class="number">0644</span>;

    <span class="variable">buff_ptr =</span> (char*)set_shm(buff_key,buff_num,shm_flg);
    <span class="variable">pput_ptr =</span> (int*)set_shm(pput_key,pput_num,shm_flg);

    <span class="variable">prod_key =</span> <span class="number">201</span>;
    <span class="variable">pmtx_key =</span> <span class="number">202</span>;
    <span class="variable">cons_key =</span> <span class="number">301</span>;
    <span class="variable">cmtx_key =</span> <span class="number">302</span>;
    <span class="variable">sem_flg =</span> IPC_CREAT | <span class="number">0644</span>;

    <span class="variable">sem_val =</span> buff_num;
    <span class="variable">prod_sem =</span> set_sem(prod_key,sem_val,sem_flg);

    <span class="variable">sem_val =</span> <span class="number">0</span>;
    <span class="variable">cons_sem =</span> set_sem(cons_key,sem_val,sem_flg);

    <span class="variable">sem_val =</span> <span class="number">1</span>;
    <span class="variable">pmtx_sem =</span> set_sem(pmtx_key,sem_val,sem_flg);

    while (<span class="number">1</span>){
        down(prod_sem);
        down(pmtx_sem);

        buff_ptr[*pput_ptr] = 'A' + *pput_ptr;
        sleep(rate);
        printf(<span class="string">"%d producer put: %c to Buffer[%d]\n"</span>,getpid(),buff_ptr[*pput_ptr],*pput_ptr);
        *<span class="variable">pput_ptr =</span> (*pput_ptr+<span class="number">1</span>) % buff_num;

        up(pmtx_sem);
        up(cons_sem);
    }

    return EXIT_SUCCESS;
}
</code></pre><p>消费者：</p>
<pre><code><span class="comment">#include "ipc.h"</span>

int main(int argc,char * argv[]){
    int rate;
    <span class="keyword">if</span> (argv[<span class="number">1</span>] != NULL) <span class="variable">rate =</span> atoi(argv[<span class="number">1</span>]);
    <span class="keyword">else</span> <span class="variable">rate =</span> <span class="number">3</span>;

    <span class="variable">buff_key =</span> <span class="number">101</span>;
    <span class="variable">buff_num =</span> <span class="number">8</span>;
    <span class="variable">cget_key =</span> <span class="number">103</span>;
    <span class="variable">cget_num =</span> <span class="number">1</span>;
    <span class="variable">shm_flg =</span> IPC_CREAT|<span class="number">0644</span>;

    <span class="variable">buff_ptr =</span> (char*)set_shm(buff_key,buff_num,shm_flg);
    <span class="variable">cget_ptr =</span> (int*)set_shm(cget_key,cget_num,shm_flg);

    <span class="variable">prod_key =</span> <span class="number">201</span>;
    <span class="variable">pmtx_key =</span> <span class="number">202</span>;
    <span class="variable">cons_key =</span> <span class="number">301</span>;
    <span class="variable">cmtx_key =</span> <span class="number">302</span>;
    <span class="variable">sem_flg =</span> IPC_CREAT|<span class="number">0644</span>;

    <span class="variable">sem_val =</span> buff_num;
    <span class="variable">prod_sem =</span> set_sem(prod_key,sem_val,sem_flg);

    <span class="variable">sem_val =</span> <span class="number">0</span>;
    <span class="variable">cons_sem =</span> set_sem(cons_key,sem_val,sem_flg);

    <span class="variable">sem_val =</span> <span class="number">1</span>;
    <span class="variable">cmtx_sem =</span> set_sem(cmtx_key,sem_val,sem_flg);

    while (<span class="number">1</span>){
        down(cons_sem);
        down(cmtx_sem);
        sleep(rate);
        printf(<span class="string">"%d consumer get: %c from Buffer[%d]\n"</span>,getpid(),buff_ptr[*cget_ptr],*cget_ptr);
        *<span class="variable">cget_ptr =</span> (*cget_ptr+<span class="number">1</span>) % buff_num;

        up(cmtx_sem);
        up(prod_sem);
    }
    return EXIT_SUCCESS;
}
</code></pre><p>可以发现，他们（所有的消费者加上所有生产者）共享一个环形缓冲区buff，但是所有生产者共享一个指针pput_ptr，所有消费者共享一个指针cget_ptr。维护两个信号量，cons_sem和prod_sem，它们俩的和维持为窗口大小(8)，也即环形缓冲区的大小。在所有消费者之间交换一把锁cmtx_sem，所有生产者之间同样。</p>
<p>每个信号量都只初始化一次，因为在ipc.c里sem_get的时候，会判断指定的key的信号量是否已存在。</p>
<p>另一个有意思的地方是权限sem_flg，IRC_CREATE是不存在则创建，644权限限制了别的进程不能修改或删除该锁。</p>
<p>另一个实验是抽咽者问题，这个问题，如果把三种材料独立成三个缓冲区，则会出现哲学家问题里的那种死锁现象，而三种材料共享一个缓冲区，每次生产者都同时生产两种东西，则不会出现这个问题。意识到这一点之后，实现就变得简单了，略过。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/HPC/">HPC</a>
</div>


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/02/Intel-Xeon-Phi协处理器高性能编程指南-总结/" title="Intel Xeon Phi协处理器高性能编程指南" itemprop="url">Intel Xeon Phi协处理器高性能编程指南</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Donald Wu" target="_blank" itemprop="author">Donald Wu</a>
		
  <p class="article-time">
    <time datetime="2015-11-02T10:42:59.327Z" itemprop="datePublished"> 發表於 2015-11-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>对读过的章节稍微做一下总结</p>
<h2 id="第二章">第二章</h2><p>线程和亲缘性：线程并不是越多越好，但至少要保证每核2个线程，因为根据现在xeon phi的设计，一个周期两条指令，预取的时候，不能用当前线程来预取。性能会减半。<br>亲缘性最好是scatter，负载均衡。</p>
<font size="1px" color="grey">这两者都既可以在程序中设置，也可以在环境变量中设置</font>

<p>内存带宽：增加核的使用，以增加内存缓冲区，但是核上线程增加可能是会牺牲内存带宽的，可以增加内存页大小</p>
<h2 id="第三章">第三章</h2><h3 id="向量化">向量化</h3><p>向量化是MIC优化的主题。</p>
<p>-O2 -O3 中实现了自动向量化<br>而ivdep补充说明了哪些块可以向量化</p>
<p>要用OpenMP扩展到多核也必须满足可向量化才行</p>
<h3 id="对齐">对齐</h3><p>前端对齐:_mm_malloc和_mm_free。（如数组首地址）<br>补白：（如二维数组行首）（注意一级cache大小)</p>
<h3 id="流存储">流存储</h3><p>写入前不读取#pragma vector nontemporal</p>
<h3 id="2MB大内存页">2MB大内存页</h3><p>mmap()</p>
<h2 id="第四章">第四章</h2><h3 id="代码扩展">代码扩展</h3><p>#pragma omp for collapse(2) 循环合并</p>
<h3 id="向量化-1">向量化</h3><p>#pragma simd 比 #pragma ivdep更强制</p>
<h3 id="剥离">剥离</h3><p>一个循环拆分成两个，以消除分支判断</p>
<h3 id="切片">切片</h3><p>多重循环的时候，不宜某一维度过长。如3维，y过长，则不能利用数据局部性，因为处理完一个x-y平面之后，才会z++，进入到下一个x-y平面，此时最前面的数据可能已经不在L2Cache中了。优化的方法是切片，并且把个切片y轴上的长度设为参数，调优。</p>
<h2 id="第五章">第五章</h2><h3 id="向量化的五种方法">向量化的五种方法</h3><ul>
<li>Cilk Plus</li>
<li>Array Notations</li>
<li>Auto-vectorization</li>
<li>SIMD Directives</li>
<li>MKL</li>
</ul>
<h3 id="六步方法论">六步方法论</h3><ul>
<li>测试基准版性能</li>
<li>用Intel Vtune Amplifier XE确定热点</li>
<li>使用英特尔编译器vec-report确定可向量化循环</li>
<li>使用英特尔编译器GAP报告和工具资源获得建议<font color="red">这是什么？还没用过</font></li>
<li>GAP实线意见及其他建议（如使用基本函数和/或数组符号）</li>
<li>重复</li>
</ul>
<h3 id="Cache流标题和下面的内容的关系是什么？">Cache流<font color="red">标题和下面的内容的关系是什么？</font></h3><ul>
<li>数据布局</li>
<li>数据对齐</li>
<li>预取 <font color="red">还不太熟悉</font><ul>
<li>硬件到L2缓存的自动预取（见第八章）</li>
<li>编译器到L1缓存的自动软件预取指令</li>
<li>编译器生成的预取（可从程序员提供的信息中获取帮助）</li>
<li>程序员通过L2和L1的预取能力进行的手动预取</li>
</ul>
</li>
<li>流存储 <ul>
<li>条件。可向量化，非时间局部性。<font color="red">还不太理解，书的翻译也不好</font></li>
<li>编译器生成clevicts。它告知硬件不预取将被彻底删除的数据，判断发生在编译时。分别讨论了处理器和协处理器上。</li>
</ul>
</li>
</ul>
<h3 id="编译器技巧一些杂技巧">编译器技巧<font color="red">一些杂技巧</font></h3><ul>
<li>避免手动展开。使用#pragma unroll。以直接了当的方式书写</li>
<li>编译器向量化的要求。几点容易理解的，和一些特殊情况。<ul>
<li>更杂的建议。可作为优化后复审的参考，这是一个总结，前面都提到过</li>
</ul>
</li>
<li>内联<br>  最内层的循环函数被自动内联很重要，用-opt-report-phase-ipo_inl观察是否内联，因为有的行为会关闭自动内联（如-pg 的性能分析功能）</li>
</ul>
<h3 id="编译器选项（同样是一些技巧）没看太懂，书写得有点混乱">编译器选项（同样是一些技巧）<font color="red">没看太懂，书写得有点混乱</font></h3><font color="red">这有一段不知所云，而且此处还没有涉及到预取</font><br>- 解决不明确，可能存在的隐含的混叠<font color="red">实际上这也是数据相关性的一种表现</font><br>    - 用restricted关键字说明指针具有独立性（即不混叠）<br>    - #pragma ivdep，允许编译器消除一些假定的相关性（而SIMD是强制性的）<br>    - 换用数组表示法或元素函数<br><br><br>###编译器指导指令，这部分内容很多<br>- SIMD<br>    - 使用的要求（底线，比ivdep的要求低），有一点比较奇怪但是也容易理解，就是循环体不能过大。另外一个奇怪的地方是，不要和快速浮点模式一起用<br><br><br><br>无主题（通用）<br>—-<br>source inte/composer**/bin/comiplervars.sh ia32/intel64 自动建立环境<br>#pragma omp master常用在输出调试信息上，只使用一个节点输出<br>private(xxx) 表示mic里和host上是独立的，不共享<br>各种优化后都要尝试不同线程数<br>在修改的时候要注意可扩展性和移植性<br><br><font color="red">明天继续补充</font>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/HPC/">HPC</a>
</div>


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/3/"><span></span>Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="顯示側邊欄"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隱藏側邊欄"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分類</p>
		<ul>
		
		  
			<li><a href="/categories/ACM/" title="ACM">ACM<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/AI/" title="AI">AI<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/CTF/" title="CTF">CTF<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Cryptography/" title="Cryptography">Cryptography<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/HPC/" title="HPC">HPC<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/Just4Fun/" title="Just4Fun">Just4Fun<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/Math/" title="Math">Math<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Networking/" title="Networking">Networking<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Programming/" title="Programming">Programming<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Security/" title="Security">Security<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Server/" title="Server">Server<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/programming/" title="programming">programming<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  

  <div class="linkslist">
  <p class="asidetitle">友情鏈接</p>
    <ul>
        
          <li>
            
            	<a href="http://blog.ikow.cn" target="_blank" title="k神">k神</a>
            
          </li>
        
          <li>
            
            	<a href="http://nlfox.sinaapp.com" target="_blank" title="狐神">狐神</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 訂閱</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> wuyihao. ^_^ <br/>
			Major in Network Engineering. Fancy 4 Algorithm, Infomation Security. Computer Network. etc</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="Donald Wu">Donald Wu</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回頂部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
